var tipuesearch = {"pages":[{"text":"diffort Deuterium diffusion in tungsten Introduction Problem Statement I will investigate the diffusion of implanted deuterium ions on a tungsten surface - a simulation of the\nfirst wall problem in fusion.  The [ \\nabla C \\ Note You can include any notes (or bugs, warnings, or todos) like so. Developer Info Alex Hagen I program stuff in Fortran.","tags":"","loc":"index.html","title":" diffort "},{"text":"Source Code program explicit_diffusion use input_output use linear_algebra use mesh implicit none real ( 8 ), allocatable , dimension (:) :: x_source , s_source real ( 8 ), allocatable , dimension (:) :: x real ( 8 ) :: Phi , D real ( 8 ) :: x_total , delta_x , delta_x_min integer ( 4 ) :: n_x real ( 8 ) :: t_final , delta_t , t integer ( 4 ) :: n_t integer ( 4 ) :: i , j , n real ( 8 ), allocatable , dimension (:) :: Ckm1 , S real ( 8 ), allocatable , dimension (:) :: C real ( 8 ) :: delta_xj , delta_xjm1 , flux real ( 8 ) :: k_r logical :: debug = . FALSE . real ( 8 ) :: t_save real ( 8 ) :: t_step integer ( 4 ) :: n_file ! setting up the parameters call init ( Phi , t_final , t_save , t_step , D , k_r , x_total , delta_x , delta_x_min , n_x ) ! Setting up the workspace call workspace_setup () !! Read in the inital distribution from a SRIM file if ( debug ) write ( * , * ) \"---- Reading the source input file...\" call read_srim ( \"RANGE.txt\" , x_source , s_source ) !! convert the depth coordinates in x from angstroms to cm x_source = x_source * 1.0 d - 8 !! convert the ion deposition source from atoms/cm&#94;3 / atoms/cm&#94;2 to just !! atoms/cm&#94;3 by multiplying by the fluence s_source = s_source * Phi !! Create a mesh if ( debug ) write ( * , * ) \"---- Creating a mesh...\" call uniformmesh ( 0.0 d0 , x_total , delta_x , n_x , x ) ! now calculate our t step for stability delta_t = delta_x ** 2.0 d0 / ( 2.0 d0 * D ) n_t = t_final / delta_t if ( debug ) write ( * , * ) \"---- Allocating matrices...\" allocate ( C ( n_x ), Ckm1 ( n_x ), S ( n_x )) !! The source term never changes, so we can calculate this only once if ( debug ) write ( * , * ) \"---- Populating integral source vector...\" do j = 1 , n_x S ( j ) = interp ( x_source , s_source , x ( j )) * delta_t end do Ckm1 = 0.0 d0 do j = 1 , n_x C ( j ) = S ( j ) end do n_file = 0 call print_output ( n_file , x , C , 0.0 d0 ) n_file = n_file + 1 !! now we can go through the time steps if ( debug ) write ( * , * ) \"---- Starting time analysis...\" t = 0.0 d0 do i = 1 , n_t ! iterate through the grid do j = 1 , n_x delta_xj = (( x ( j ) - x ( j - 1 )) + & ( x ( j + 1 ) - x ( j ))) / 2.0 d0 delta_xjm1 = ( x ( j ) - x ( j - 1 )) ! perform the predictor step (euler) if ( j . eq . 1 ) then flux = - k_r * Ckm1 ( j ) ** 2.0 d0 / D + D * ( Ckm1 ( j + 1 ) - 2.0 d0 * & Ckm1 ( j ) + Ckm1 ( j - 1 )) / ( delta_xj ) / delta_xj else flux = D * ( Ckm1 ( j + 1 ) - 2.0 d0 * Ckm1 ( j ) + Ckm1 ( j - 1 )) / & ( delta_xj ) / delta_xj end if C ( j ) = Ckm1 ( j ) + flux * delta_t + S ( j ) end do C ( n_x ) = 0.0 d0 ! save our updated array to the \"last step\" array and the ghost cells Ckm1 = C if ( dabs ( t - t_save ) < 1.0 d - 15 ) then call print_output ( n_file , x , C , t ) n_file = n_file + 1 t_save = t_save + t_step end if t = t + delta_t if ( debug ) write ( * , * ) \"---- Next time step...\" end do deallocate ( C , Ckm1 , S ) end program","tags":"","loc":"sourcefile/explicit.f90.html","title":"explicit.f90 – diffort"},{"text":"Source Code program implicit_diffusion use input_output use linear_algebra use mesh implicit none real ( 8 ), allocatable , dimension (:) :: x_source , s_source real ( 8 ), allocatable , dimension (:) :: x real ( 8 ) :: Phi , D real ( 8 ) :: x_total , delta_x , delta_x_min integer ( 4 ) :: n_x real ( 8 ) :: t_final , delta_t , t integer ( 4 ) :: n_t integer ( 4 ) :: i , j , n real ( 8 ), allocatable , dimension (:,:) :: K , M , Mkm1 , A real ( 8 ), allocatable , dimension (:) :: Ckm1 , l , S , b , Mkm1Ckm1 real ( 8 ), allocatable , dimension (:) :: C real ( 8 ) :: delta_xj , delta_xjm1 real ( 8 ) :: k_r logical :: debug = . FALSE . real ( 8 ) :: t_save , t_step integer ( 4 ) :: n_file ! setting up the parameters call init ( Phi , t_final , t_save , t_step , D , k_r , x_total , delta_x , delta_x_min , n_x ) ! Setting up the workspace call workspace_setup () !! Read in the inital distribution from a SRIM file if ( debug ) write ( * , * ) \"---- Reading the source input file...\" call read_srim ( \"RANGE.txt\" , x_source , s_source ) !! convert the depth coordinates in x from angstroms to cm x_source = x_source * 1.0 d - 8 !! convert the ion deposition source from atoms/cm&#94;3 / atoms/cm&#94;2 to just !! atoms/cm&#94;3 by multiplying by the fluence s_source = s_source * Phi !! Create a mesh if ( debug ) write ( * , * ) \"---- Creating a mesh...\" call uniformmesh ( 0.0 d0 , x_total , delta_x , n_x , x ) delta_t = delta_x ** 2.0 d0 / ( 2.0 d0 * D ) delta_t = t_final / 1000 0.0 d0 n_t = t_final / delta_t !! Lets actually create a stiffness matrix, dissipation matrix, source term, !! history term, and forcing term if ( debug ) write ( * , * ) \"---- Allocating matrices...\" allocate ( K ( n_x , n_x ), M ( n_x , n_x ), Mkm1 ( n_x , n_x ), A ( n_x , n_x )) allocate ( C ( n_x ), Ckm1 ( n_x ), l ( n_x ), b ( n_x ), S ( n_x )) !! The source term never changes, so we can calculate this only once if ( debug ) write ( * , * ) \"---- Populating integral source vector...\" do j = 1 , n_x S ( j ) = interp ( x_source , s_source , x ( j )) * delta_t end do if ( debug ) write ( * , * ) \"---- Initializing matrices...\" M = 0.0 d0 Mkm1 = 0.0 d0 Ckm1 = 0.0 d0 do j = 1 , n_x C ( j ) = S ( j ) end do n_file = 0 call print_output ( n_file , x , C , 0.0 d0 ) n_file = n_file + 1 !! The dissipation matrix and history dissipation matrix never change, so we can !! calculate this only once if ( debug ) write ( * , * ) \"---- Populating dissipation matrix...\" do j = 1 , n_x if ( j - 1 > 0 ) M ( j , j - 1 ) = delta_x / ( 6.0 d0 * D * delta_t ) M ( j , j ) = 4.0 d0 * delta_x / ( 6.0 d0 * delta_t * D ) if ( j < n_x ) M ( j , j + 1 ) = delta_x / ( 6.0 d0 * D * delta_t ) ! if (j - 1 > 0) Mkm1(j, j - 1) = delta_x / (6.0d0 * D * delta_t) Mkm1 ( j , j ) = delta_x / ( delta_t * D ) ! if (j < n_x) Mkm1(j, j + 1) = delta_x / (6.0d0 * D * delta_t) end do M ( 1 , 1 ) = 2.0 d0 * M ( 1 , 1 ) Mkm1 ( 1 , 1 ) = Mkm1 ( 1 , 1 ) / 2.0 d0 !! now we can go through the time steps if ( debug ) write ( * , * ) \"---- Starting time analysis...\" t = 0.0 d0 do i = 1 , n_t if ( debug ) write ( * , * ) \"---- Initializing mutable matrices...\" !! initialize all of the matices and vectors to zero do j = 1 , n_x do n = 1 , n_x K ( j , n ) = 0.0 d0 A ( j , n ) = 0.0 d0 end do l ( j ) = 0.0 d0 C ( j ) = 0.0 d0 b ( j ) = 0.0 d0 end do if ( debug ) write ( * , * ) \"---- Populating forcing element...\" !! construct the first term of the forcing element l ( 1 ) = - k_r * Ckm1 ( 1 ) ** 2.0 d0 / D if ( debug ) write ( * , * ) \"---- Populating stiffness matrix...\" !! Loop through the mesh elements and construct the terms do j = 1 , n_x !! find the mesh spacing delta_xjm1 = x ( j ) - x ( j - 1 ) delta_xj = x ( j + 1 ) - x ( j ) !! now we can create the stiffness matrix if ( j - 1 > 0 ) K ( j , j - 1 ) = - 1.0 d0 / ( delta_xjm1 ) K ( j , j ) = 1.0 d0 / ( delta_xjm1 ) + 1.0 d0 / ( delta_xj ) if ( j < n_x ) K ( j , j + 1 ) = - 1.0 d0 / ( delta_xj ) end do if ( debug ) write ( * , * ) \"---- Combining matrices to form A...\" do j = 1 , n_x do n = 1 , n_x A ( j , n ) = K ( j , n ) + M ( j , n ) end do end do !! Then, solve the matrix and print the solution if ( debug ) write ( * , * ) \"---- Multiplying history dissipation term with history vector...\" call matvecmult ( Mkm1 , Ckm1 , Mkm1Ckm1 ) if ( debug ) write ( * , * ) \"---- Combining vectors to form b...\" do j = 1 , n_x b ( j ) = l ( j ) + Mkm1Ckm1 ( j ) end do do j = 1 , n_x A ( n_x , j ) = 0.0 d0 A ( j , n_x ) = 0.0 d0 end do A ( n_x , n_x ) = 1.0 d0 b ( n_x ) = 0.0 d0 if ( debug ) write ( * , * ) \"---- Solving system of equations...\" call solve ( A , C , b ) if ( debug ) write ( * , * ) \"---- Adding source to the equations...\" do j = 1 , n_x C ( j ) = C ( j ) + S ( j ) end do if ( debug ) write ( * , * ) \"---- Outputting...\" if ( dabs ( t - t_save ) < 1.0 d - 15 ) then call print_output ( n_file , x , C , t ) n_file = n_file + 1 t_save = t_save + t_step end if if ( debug ) write ( * , * ) \"---- Incrementing time...\" do j = 1 , n_x Ckm1 ( j ) = C ( j ) end do t = t + delta_t if ( debug ) write ( * , * ) \"---- Next time step...\" end do deallocate ( K , M , Mkm1 , A ) deallocate ( C , Ckm1 , l , b , S ) end program","tags":"","loc":"sourcefile/implicit.f90.html","title":"implicit.f90 – diffort"},{"text":"Source Code module input_output use variables implicit none contains subroutine init ( Phi , t_final , t_save , t_step , D , k_r , x_total , delta_x , delta_x_min , n_x ) !! sets up parameters as defined by the problem statement real ( 8 ), intent ( out ) :: Phi !! the flux \\Phi real ( 8 ), intent ( out ) :: D !! the diffusion coefficient D in \\mathrm{\\frac{x}{x}} real ( 8 ), intent ( out ) :: x_total real ( 8 ), intent ( out ) :: delta_x real ( 8 ), intent ( out ) :: delta_x_min integer ( 4 ), intent ( out ) :: n_x real ( 8 ), intent ( out ) :: k_r real ( 8 ), intent ( out ) :: t_final real ( 8 ), intent ( out ) :: t_save real ( 8 ), intent ( out ) :: t_step ! Define the fluence in atoms/cm&#94;2 of deuterium incident on the surface Phi = 1.0 d17 ! Define the total time we are watching this as 1 microsecond t_final = 1.0 d - 3 t_save = t_final / 10 0.0 d0 t_step = t_save ! set the diffusion coefficient D = 5.0 d - 8 ! in cm&#94;2 / s ! set the removal coefficient k_r = 7.0 d - 22 ! in cm&#94;4 / s x_total = 1.0 d - 5 ! in cm delta_x = 1.0 d - 7 ! in cm delta_x_min = 1.0 d - 9 ! in cm n_x = x_total / delta_x end subroutine subroutine print_output ( n , x , y , t ) !! prints out the output of file n including the mesh points \\vec{x} !! and their values \\vec{y} integer ( 4 ), intent ( in ) :: n !! the file number real ( 8 ), dimension (:), intent ( in ) :: x !! the mesh grid \\vec{x} real ( 8 ), dimension (:), intent ( in ) :: y !! the values \\vec{y} on the mesh grid \\vec{x} real ( 8 ), intent ( in ) :: t !! the time at which this mesh was taken character ( 6 ) :: files ! a string container for the filename integer ( 4 ) :: i ! a counter integer ( 4 ) :: fh ! the filehandler ! initialize the filehandler fh = 100 + n ! make a file name with the time step number write ( files , '(I6)' ) n do i = 1 , 6 if ( files ( i : i ) == ' ' ) files ( i : i ) = '0' end do open ( fh , file = './sim/' // files // '.dat' ) write ( fh , \"(A,E20.5E4)\" ) \"# t = \" , t do i = 1 , size ( y ) write ( fh , \"(2E20.5E4)\" ) x ( i + 1 ), y ( i ) end do close ( fh ) end subroutine subroutine workspace_setup () !! This subroutine will setup a workspace for us to generate and save our !! simulation files in ! set up a folder to hold our output files call system ( 'mkdir -p sim' ) return end subroutine subroutine read_srim ( filename , x , s ) !! This subroutine opens a SRIM output file and reads the distribution of !! ions in the sample, outputting those to x and s ! Arguments character ( len =* ), intent ( in ) :: filename !! the name of the SRIM output file - usually RANGE.txt real ( 8 ), allocatable , dimension (:), intent ( out ) :: x !! the right hand x coordinate of the depth bin real ( 8 ), allocatable , dimension (:), intent ( out ) :: s !! the amount of ions deposited in the bin character ( 100 ) :: buffer integer ( 4 ) :: n , j , i , eof = 0 real ( 8 ) :: dummy ! open the file open ( 10 , file = filename ) ! initialize our line counter to zero n = 0 j = 0 do ! run through lines until we find one with data read ( 10 , \"(A)\" , iostat = eof ) buffer if ( eof < 0 ) exit if ( buffer (: 1 ) . ne . '#' ) then n = n + 1 else j = j + 1 end if end do ! rewind to the start rewind ( 10 ) ! read through all headers do i = 1 , j read ( 10 , \"(A)\" ) buffer end do ! allocate our array allocate ( x ( n ), s ( n )) ! read through every data points do i = 1 , n read ( 10 , \"(3E12.0E2)\" ) x ( i ), s ( i ), dummy end do close ( 10 ) end subroutine end module input_output","tags":"","loc":"sourcefile/input_output.f90.html","title":"input_output.f90 – diffort"},{"text":"Source Code module linear_algebra use variables implicit none contains function interp ( x , f , x_i ) !! find a linearly interpolated value of a function f\\left(x\\right) at !! point x_{i} given values of the function in \\vec{f} at points !! \\vec{x} ! Arguments real ( 8 ), dimension (:) :: f !! the function points real ( 8 ), dimension (:) :: x !! the mesh on which the function points are provided real ( 8 ) :: x_i !! the point at which the function value is desired real ( 8 ) :: interp !! the value at point x_i integer ( 4 ) :: i , j if ( x_i < x ( 1 )) then interp = f ( 1 ) return end if if ( x_i > x ( size ( x ))) then interp = f ( size ( x )) return end if ! First, find the inteval in x where x_i resides do i = 2 , size ( x ) if ( x ( i ) >= x_i . and . x ( i - 1 ) <= x_i ) exit end do ! now, linearly interpolate the value and return it interp = ( x_i - x ( i - 1 )) / ( x ( i ) - x ( i - 1 )) * ( f ( i ) - f ( i - 1 )) & + f ( i - 1 ) return end function subroutine matvecmult ( M , v , outv ) !! multiply a matrix \\mathbb{M} and a vector \\vec{v} and get result !! \\vec{outv} ! Arguments real ( 8 ), dimension (:,:), intent ( in ) :: M !! The matrix real ( 8 ), dimension (:), intent ( in ) :: v !! The vector real ( 8 ), dimension (:), allocatable , intent ( out ) :: outv !! The result integer ( 4 ) :: i , j ! allocate the output vector allocate ( outv ( size ( v ))) ! initialize the result to zero outv = 0.0 d0 do i = 1 , size ( v ) do j = 1 , size ( v ) outv ( i ) = outv ( i ) + M ( i , j ) * v ( j ) end do end do end subroutine subroutine solve ( A , x , b ) !! solve the equation \\mathbb{A}\\vec{x} = \\vec{b} for \\vec{x} using !! Gauss-Seidel method ! Arguments real ( 8 ), dimension (:,:), intent ( in ) :: A !! The matrix \\mathbb{A} to be inverted real ( 8 ), dimension (:), intent ( in ) :: b !! The vector \\vec{b} with the boundary conditions real ( 8 ), dimension (:), intent ( out ) :: x !! The vector solution \\vec{x} integer ( 4 ) :: i , j ! some counters real ( 8 ) :: sum1 , sum2 , oldx ! some holder variables real ( 8 ) :: epsilon ! convergence criteria ! initialize to ones (guesses) x = 1.0 d0 epsilon = 1.0 d0 do while ( epsilon > 1.0 d - 4 ) epsilon = 0.0 d0 do i = 1 , size ( x ) oldx = x ( i ) sum1 = 0.0 d0 sum2 = 0.0 d0 do j = 1 , i - 1 sum1 = sum1 + A ( i , j ) * x ( j ) end do do j = i + 1 , size ( x ) sum2 = sum2 + A ( i , j ) * x ( j ) end do x ( i ) = ( 1.0 d0 / A ( i , i )) * ( b ( i ) - sum1 - sum2 ) if ( dabs ( x ( i ) - oldx ) > epsilon ) epsilon = dabs ( x ( i ) - oldx ) end do end do end subroutine end module linear_algebra","tags":"","loc":"sourcefile/linear_algebra.f90.html","title":"linear_algebra.f90 – diffort"},{"text":"Source Code module mesh use variables implicit none contains subroutine uniformmesh ( x1 , x2 , delta_x , n_x , x ) !! creates a uniform mesh with size delta_x ! Arguments real ( 8 ), intent ( in ) :: x1 !! the left size of the mesh boundary real ( 8 ), intent ( in ) :: x2 !! the right side of the mesh boundary real ( 8 ), intent ( in ) :: delta_x !! the largest element size real ( 8 ), dimension (:), allocatable :: x !! the mesh midpoints integer ( 4 ), intent ( out ) :: n_x !! the number of mesh elements integer ( 4 ) :: i , j ! counters ! determine the number of mesh elements n_x = ( x2 - x1 ) / delta_x ! allocate and create the uniform z mesh allocate ( x ( 0 : n_x + 1 )) x ( 0 ) = x1 - delta_x x ( 1 ) = x1 X ( 2 ) = x1 + delta_x do j = 3 , n_x + 1 x ( j ) = x ( j - 1 ) + delta_x end do ! now calculate the midpoints do j = 0 , n_x x ( j ) = ( x ( j ) + x ( j + 1 )) / 2.0 d0 end do end subroutine subroutine nonuniformmesh ( x1 , x2 , delta_x , delta_x_min , n_x , x ) !! creates a nonuniform mesh with size varying from delta_x_min on the left !! edge of the boundary to delta_x on the right edge of the boundary.  The !! element sizes vary as \\log\\left(\\frac{a}{a&#94;{n}}\\right) ! Arguments real ( 8 ), intent ( in ) :: x1 !! the left size of the mesh boundary real ( 8 ), intent ( in ) :: x2 !! the right side of the mesh boundary real ( 8 ), intent ( in ) :: delta_x !! the largest element size real ( 8 ), intent ( in ) :: delta_x_min !! the smallest element size real ( 8 ), dimension (:), allocatable :: x !! the mesh midpoints integer ( 4 ), intent ( out ) :: n_x !! the number of mesh elements real ( 8 ) :: mesh_s , kappa , alpha ! some meshing variables integer ( 4 ) :: i , j ! counters ! determine the number of mesh elements n_x = ( x2 - x1 ) / delta_x ! allocate and create the uniform z mesh allocate ( x ( 0 : n_x + 1 )) x ( 0 ) = x1 - delta_x_min x ( 1 ) = x1 X ( 2 ) = x1 + delta_x_min do j = 3 , n_x + 1 x ( j ) = x ( j - 1 ) + delta_x end do ! now calculate the non-uniform mesh parameters mesh_s = x2 - x1 alpha = dlog10 ( delta_x_min / mesh_s ) / dlog10 ( delta_x / mesh_s ) kappa = mesh_s ** ( 1.0 d0 - alpha ) ! now apply that to move all of the left points do j = 3 , n_x + 1 x ( j ) = (( x ( j ) - x ( j - 1 )) ** alpha ) * kappa end do ! now calculate the midpoints do j = 0 , n_x x ( j ) = ( x ( j ) + x ( j + 1 )) / 2.0 d0 end do end subroutine end module mesh","tags":"","loc":"sourcefile/mesh.f90.html","title":"mesh.f90 – diffort"},{"text":"Source Code module variables integer , parameter :: dp = kind ( 1.0 d0 ) integer , parameter :: wp = dp real ( wp ), parameter :: pi = 3.1415926535897932384626433832795028841971693993751058_wp end module variables","tags":"","loc":"sourcefile/variables.f90.html","title":"variables.f90 – diffort"},{"text":"Source Code import numpy as np from scipy import integrate import sys sys . path . append ( \"/Users/ahagen/code\" ) from pymf import ctmfd as ahi from pym import func as ahf from pyg import twod as ahp import glob plot = ahp . ah2d () fname = glob . glob ( 'fem_sol/*.dat' ) for i in range ( len ( fname )): arr = np . loadtxt ( fname [ i ]) z = arr [:, 0 ] * 1.0E4 C = arr [:, 1 ] fem = ahf . curve ( z , C , name = r'fem' ) plot = fem . plot ( linestyle = '-' , linecolor = '#5C8727' ) plot . lines_on () plot . markers_off () arr = np . loadtxt ( fname [ i ] . replace ( 'fem' , 'fdm' )) z = arr [:, 0 ] * 1.0E4 C = arr [:, 1 ] fdm = ahf . curve ( z , C , name = r'fdm' ) fdm . plot ( linestyle = '-' , linecolor = '#2EAFA4' , addto = plot ) plot . lines_on () plot . markers_off () for x in z [:: 10 ]: plot . add_vline ( x , 0.0 , 5.0E17 , lw = 0.5 , color = '#D1D3D4' ) arr = np . loadtxt ( 'RANGE.txt' ) z = 1.0E-8 * np . array ( arr [:, 0 ]) * 1.0E4 S = 1.0E17 * np . array ( arr [:, 1 ]) * 1.0E-6 t = float ( filter ( str . isdigit , fname [ i ])) * 1.0E-5 * 1.0E6 plot . fill_between ( z , np . zeros_like ( S ), S , fc = '#D1D3D4' , name = r'$\\vec{S}$' ) plot . add_text ( 0.75E-1 , 2.E17 , string = r'$ %4.1f \\,\\mu s$' % ( t ), ha = 'left' ) plot . ylabel ( r'Concentration ($C$) [$\\mathrm{\\frac{atoms}{cm&#94;{3}}}$]' ) plot . xlabel ( r'Position ($z$) [$\\mathrm{\\mu m}$]' ) plot . legend () plot . ylim ( 0.0 , 5.0E17 ) plot . export ( '../img/full_result_ %02d ' % ( i ), formats = [ 'png' , 'pgf' ], sizes = [ 'cs' ], customsize = ( 4.25 , 2.125 )) #plot.show()","tags":"","loc":"sourcefile/diffusion.py.html","title":"diffusion.py – diffort"},{"text":"public subroutine init(Phi, t_final, t_save, t_step, D, k_r, x_total, delta_x, delta_x_min, n_x) Arguments Type Intent Optional Attributes Name real(kind=8), intent(out) :: Phi the flux \\Phi real(kind=8), intent(out) :: t_final real(kind=8), intent(out) :: t_save real(kind=8), intent(out) :: t_step real(kind=8), intent(out) :: D the diffusion coefficient D in \\mathrm{\\frac{x}{x}} real(kind=8), intent(out) :: k_r real(kind=8), intent(out) :: x_total real(kind=8), intent(out) :: delta_x real(kind=8), intent(out) :: delta_x_min integer(kind=4), intent(out) :: n_x Description sets up parameters as defined by the problem statement","tags":"","loc":"proc/init.html","title":"init – diffort"},{"text":"public subroutine print_output(n, x, y, t) Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in) :: n the file number real(kind=8), intent(in), dimension(:) :: x the mesh grid \\vec{x} real(kind=8), intent(in), dimension(:) :: y the values \\vec{y} on the mesh grid \\vec{x} real(kind=8), intent(in) :: t the time at which this mesh was taken Description prints out the output of file n including the mesh points \\vec{x}\n and their values \\vec{y} Variables Type Visibility Attributes Name Initial character(len=6), public :: files integer(kind=4), public :: i integer(kind=4), public :: fh","tags":"","loc":"proc/print_output.html","title":"print_output – diffort"},{"text":"public subroutine workspace_setup() Arguments None Description This subroutine will setup a workspace for us to generate and save our\n simulation files in","tags":"","loc":"proc/workspace_setup.html","title":"workspace_setup – diffort"},{"text":"public subroutine read_srim(filename, x, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename the name of the SRIM output file - usually RANGE.txt real(kind=8), intent(out), allocatable, dimension(:) :: x the right hand x coordinate of the depth bin real(kind=8), intent(out), allocatable, dimension(:) :: s the amount of ions deposited in the bin Description This subroutine opens a SRIM output file and reads the distribution of\n ions in the sample, outputting those to x and s Variables Type Visibility Attributes Name Initial character(len=100), public :: buffer integer(kind=4), public :: n integer(kind=4), public :: j integer(kind=4), public :: i integer(kind=4), public :: eof = 0 real(kind=8), public :: dummy","tags":"","loc":"proc/read_srim.html","title":"read_srim – diffort"},{"text":"public function interp(x, f, x_i) Arguments Type Intent Optional Attributes Name real(kind=8), , dimension(:) :: x the mesh on which the function points are provided real(kind=8), , dimension(:) :: f the function points real(kind=8) :: x_i the point at which the function value is desired Return Value real(kind=8) the value at point x_i Description find a linearly interpolated value of a function f\\left(x\\right) at\n point x_{i} given values of the function in \\vec{f} at points\n \\vec{x} Variables Type Visibility Attributes Name Initial integer(kind=4), public :: i integer(kind=4), public :: j","tags":"","loc":"proc/interp.html","title":"interp – diffort"},{"text":"public subroutine matvecmult(M, v, outv) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:,:) :: M The matrix real(kind=8), intent(in), dimension(:) :: v The vector real(kind=8), intent(out), dimension(:), allocatable :: outv The result Description multiply a matrix \\mathbb{M} and a vector \\vec{v} and get result\n \\vec{outv} Variables Type Visibility Attributes Name Initial integer(kind=4), public :: i integer(kind=4), public :: j","tags":"","loc":"proc/matvecmult.html","title":"matvecmult – diffort"},{"text":"public subroutine solve(A, x, b) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:,:) :: A The matrix \\mathbb{A} to be inverted real(kind=8), intent(out), dimension(:) :: x The vector solution \\vec{x} real(kind=8), intent(in), dimension(:) :: b The vector \\vec{b} with the boundary conditions Description solve the equation \\mathbb{A}\\vec{x} = \\vec{b} for \\vec{x} using\n Gauss-Seidel method Variables Type Visibility Attributes Name Initial integer(kind=4), public :: i integer(kind=4), public :: j real(kind=8), public :: sum1 real(kind=8), public :: sum2 real(kind=8), public :: oldx real(kind=8), public :: epsilon","tags":"","loc":"proc/solve.html","title":"solve – diffort"},{"text":"public subroutine uniformmesh(x1, x2, delta_x, n_x, x) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: x1 the left size of the mesh boundary real(kind=8), intent(in) :: x2 the right side of the mesh boundary real(kind=8), intent(in) :: delta_x the largest element size integer(kind=4), intent(out) :: n_x the number of mesh elements real(kind=8), , dimension(:), allocatable :: x the mesh midpoints Description creates a uniform mesh with size delta_x Variables Type Visibility Attributes Name Initial integer(kind=4), public :: i integer(kind=4), public :: j","tags":"","loc":"proc/uniformmesh.html","title":"uniformmesh – diffort"},{"text":"public subroutine nonuniformmesh(x1, x2, delta_x, delta_x_min, n_x, x) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: x1 the left size of the mesh boundary real(kind=8), intent(in) :: x2 the right side of the mesh boundary real(kind=8), intent(in) :: delta_x the largest element size real(kind=8), intent(in) :: delta_x_min the smallest element size integer(kind=4), intent(out) :: n_x the number of mesh elements real(kind=8), , dimension(:), allocatable :: x the mesh midpoints Description creates a nonuniform mesh with size varying from delta_x_min on the left\n edge of the boundary to delta_x on the right edge of the boundary.  The\n element sizes vary as \\log\\left(\\frac{a}{a&#94;{n}}\\right) Variables Type Visibility Attributes Name Initial real(kind=8), public :: mesh_s real(kind=8), public :: kappa real(kind=8), public :: alpha integer(kind=4), public :: i integer(kind=4), public :: j","tags":"","loc":"proc/nonuniformmesh.html","title":"nonuniformmesh – diffort"},{"text":"Uses: variables Subroutines public subroutine init (Phi, t_final, t_save, t_step, D, k_r, x_total, delta_x, delta_x_min, n_x) Arguments Type Intent Optional Attributes Name real(kind=8), intent(out) :: Phi the flux \\Phi real(kind=8), intent(out) :: t_final real(kind=8), intent(out) :: t_save real(kind=8), intent(out) :: t_step real(kind=8), intent(out) :: D the diffusion coefficient D in \\mathrm{\\frac{x}{x}} real(kind=8), intent(out) :: k_r real(kind=8), intent(out) :: x_total real(kind=8), intent(out) :: delta_x real(kind=8), intent(out) :: delta_x_min integer(kind=4), intent(out) :: n_x Description sets up parameters as defined by the problem statement public subroutine print_output (n, x, y, t) Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in) :: n the file number real(kind=8), intent(in), dimension(:) :: x the mesh grid \\vec{x} real(kind=8), intent(in), dimension(:) :: y the values \\vec{y} on the mesh grid \\vec{x} real(kind=8), intent(in) :: t the time at which this mesh was taken Description prints out the output of file n including the mesh points \\vec{x}\n and their values \\vec{y} public subroutine workspace_setup () Arguments None Description This subroutine will setup a workspace for us to generate and save our\n simulation files in public subroutine read_srim (filename, x, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename the name of the SRIM output file - usually RANGE.txt real(kind=8), intent(out), allocatable, dimension(:) :: x the right hand x coordinate of the depth bin real(kind=8), intent(out), allocatable, dimension(:) :: s the amount of ions deposited in the bin Description This subroutine opens a SRIM output file and reads the distribution of\n ions in the sample, outputting those to x and s","tags":"","loc":"module/input_output.html","title":"input_output – diffort"},{"text":"Uses: variables Functions public function interp (x, f, x_i) Arguments Type Intent Optional Attributes Name real(kind=8), , dimension(:) :: x the mesh on which the function points are provided real(kind=8), , dimension(:) :: f the function points real(kind=8) :: x_i the point at which the function value is desired Return Value real(kind=8) the value at point x_i Description find a linearly interpolated value of a function f\\left(x\\right) at\n point x_{i} given values of the function in \\vec{f} at points\n \\vec{x} Subroutines public subroutine matvecmult (M, v, outv) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:,:) :: M The matrix real(kind=8), intent(in), dimension(:) :: v The vector real(kind=8), intent(out), dimension(:), allocatable :: outv The result Description multiply a matrix \\mathbb{M} and a vector \\vec{v} and get result\n \\vec{outv} public subroutine solve (A, x, b) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:,:) :: A The matrix \\mathbb{A} to be inverted real(kind=8), intent(out), dimension(:) :: x The vector solution \\vec{x} real(kind=8), intent(in), dimension(:) :: b The vector \\vec{b} with the boundary conditions Description solve the equation \\mathbb{A}\\vec{x} = \\vec{b} for \\vec{x} using\n Gauss-Seidel method","tags":"","loc":"module/linear_algebra.html","title":"linear_algebra – diffort"},{"text":"Uses: variables Subroutines public subroutine uniformmesh (x1, x2, delta_x, n_x, x) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: x1 the left size of the mesh boundary real(kind=8), intent(in) :: x2 the right side of the mesh boundary real(kind=8), intent(in) :: delta_x the largest element size integer(kind=4), intent(out) :: n_x the number of mesh elements real(kind=8), , dimension(:), allocatable :: x the mesh midpoints Description creates a uniform mesh with size delta_x public subroutine nonuniformmesh (x1, x2, delta_x, delta_x_min, n_x, x) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: x1 the left size of the mesh boundary real(kind=8), intent(in) :: x2 the right side of the mesh boundary real(kind=8), intent(in) :: delta_x the largest element size real(kind=8), intent(in) :: delta_x_min the smallest element size integer(kind=4), intent(out) :: n_x the number of mesh elements real(kind=8), , dimension(:), allocatable :: x the mesh midpoints Description creates a nonuniform mesh with size varying from delta_x_min on the left\n edge of the boundary to delta_x on the right edge of the boundary.  The\n element sizes vary as \\log\\left(\\frac{a}{a&#94;{n}}\\right)","tags":"","loc":"module/mesh.html","title":"mesh – diffort"},{"text":"Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = kind(1.0d0) integer, public, parameter :: wp = dp real(kind=wp), public, parameter :: pi = 3.1415926535897932384626433832795028841971693993751058_wp","tags":"","loc":"module/variables.html","title":"variables – diffort"},{"text":"Uses: input_output linear_algebra mesh Read in the inital distribution from a SRIM file\n convert the depth coordinates in x from angstroms to cm\n convert the ion deposition source from atoms/cm&#94;3 / atoms/cm&#94;2 to just\n atoms/cm&#94;3 by multiplying by the fluence\n Create a mesh\n The source term never changes, so we can calculate this only once\n now we can go through the time steps Variables Type Attributes Name Initial real(kind=8), allocatable, dimension(:) :: x_source real(kind=8), allocatable, dimension(:) :: s_source real(kind=8), allocatable, dimension(:) :: x real(kind=8) :: Phi real(kind=8) :: D real(kind=8) :: x_total real(kind=8) :: delta_x real(kind=8) :: delta_x_min integer(kind=4) :: n_x real(kind=8) :: t_final real(kind=8) :: delta_t real(kind=8) :: t integer(kind=4) :: n_t integer(kind=4) :: i integer(kind=4) :: j integer(kind=4) :: n real(kind=8), allocatable, dimension(:) :: Ckm1 real(kind=8), allocatable, dimension(:) :: S real(kind=8), allocatable, dimension(:) :: C real(kind=8) :: delta_xj real(kind=8) :: delta_xjm1 real(kind=8) :: flux real(kind=8) :: k_r logical :: debug = .FALSE. real(kind=8) :: t_save real(kind=8) :: t_step integer(kind=4) :: n_file","tags":"","loc":"program/explicit_diffusion.html","title":"explicit_diffusion – diffort"},{"text":"Uses: input_output linear_algebra mesh Read in the inital distribution from a SRIM file\n convert the depth coordinates in x from angstroms to cm\n convert the ion deposition source from atoms/cm&#94;3 / atoms/cm&#94;2 to just\n atoms/cm&#94;3 by multiplying by the fluence\n Create a mesh\n Lets actually create a stiffness matrix, dissipation matrix, source term,\n history term, and forcing term\n The source term never changes, so we can calculate this only once\n The dissipation matrix and history dissipation matrix never change, so we can\n calculate this only once\n now we can go through the time steps\n initialize all of the matices and vectors to zero\n construct the first term of the forcing element\n Loop through the mesh elements and construct the terms\n find the mesh spacing\n now we can create the stiffness matrix\n Then, solve the matrix and print the solution Variables Type Attributes Name Initial real(kind=8), allocatable, dimension(:) :: x_source real(kind=8), allocatable, dimension(:) :: s_source real(kind=8), allocatable, dimension(:) :: x real(kind=8) :: Phi real(kind=8) :: D real(kind=8) :: x_total real(kind=8) :: delta_x real(kind=8) :: delta_x_min integer(kind=4) :: n_x real(kind=8) :: t_final real(kind=8) :: delta_t real(kind=8) :: t integer(kind=4) :: n_t integer(kind=4) :: i integer(kind=4) :: j integer(kind=4) :: n real(kind=8), allocatable, dimension(:,:) :: K real(kind=8), allocatable, dimension(:,:) :: M real(kind=8), allocatable, dimension(:,:) :: Mkm1 real(kind=8), allocatable, dimension(:,:) :: A real(kind=8), allocatable, dimension(:) :: Ckm1 real(kind=8), allocatable, dimension(:) :: l real(kind=8), allocatable, dimension(:) :: S real(kind=8), allocatable, dimension(:) :: b real(kind=8), allocatable, dimension(:) :: Mkm1Ckm1 real(kind=8), allocatable, dimension(:) :: C real(kind=8) :: delta_xj real(kind=8) :: delta_xjm1 real(kind=8) :: k_r logical :: debug = .FALSE. real(kind=8) :: t_save real(kind=8) :: t_step integer(kind=4) :: n_file","tags":"","loc":"program/implicit_diffusion.html","title":"implicit_diffusion – diffort"}]}